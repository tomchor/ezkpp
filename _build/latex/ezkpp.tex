% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,openany,oneside]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{An easy guide for KPP}
\date{Nov 15, 2016}
\release{0.1}
\author{Tomas Chor}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{wheat_field.jpg}\par}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


You can download this guide in pdf
\href{https://github.com/tomchor/ezkpp/raw/gh-pages/ezkpp.pdf}{here}.

You can acces the html version \href{https://tomchor.github.io/ezkpp/}{here}.

Contents:


\chapter{Introduction}
\label{README:introduction}\label{README:easy-guide-to-compiling-and-running-kpp}\label{README::doc}
This is an unofficial guide is aimed at providing additional information not
covered by the official KPP manual. We focus on the latest version of the
software, release 2.2.3, which can be freely downloaded at its \href{http://people.cs.vt.edu/~asandu/Software/Kpp/}{official
webpage}.

The source for the documentation can be found at its \href{https://github.com/tomchor/ezkpp}{github page} and the online html version can be
accessed \href{https://tomchor.github.io/ezkpp/}{here}.

We recommend any person reading this guide to keep a copy of the original
manual (which can be downloaded \href{http://people.cs.vt.edu/~asandu/Software/Kpp/}{here}) since this guide is not
meant to replace the original manual, but to supplement it.


\chapter{About bash}
\label{bash:about-bash}\label{bash::doc}
The official KPP manual is entirely based on Unix Shell, which is command
language which most of the Linux distrobutions use to interact with the system
without a Graphical User Interface. The manual, however, assumes a non-trivial
knowledge of this tool, which makes it difficult for users not experienced with
terminals and command line interfaces (which includes bash, C shell, MS-DOS,
PowerShell, ksh etc.) to install and run the simulations effectively. The
approach adopted in this guide will be to go through the steps necessary to
compile and run KPP, as stated in the manual, but taking the time to explain
them a little better how to do them, and what exactly it is that they do.

We will first go over a few basic notions necessary to understand what is going
to be done in the guide. If you are familiar with the concepts of system shells,
you may skip the next sections.


\section{What is Bash?}
\label{bash:what-is-bash}
But what is a shell? A system shell is the name what computer engineers use to
refer to the outter layer of an Operaional System (OS). It is said outter layer
because it separates the user (you) from the core of your OS. So it separates
you from the intricate group of codes that ultimately governs your machine and
lets you interact with your computer using a human-readable language (and not,
for example, binary!). So a shell is a bridge between you and your machine.

These shells can be either graphical shells (called Graphical User Interface,
GUI, just like what you use during mundane tasks such as browsing the web and
reading a PDF document) or text shells (also called terminals or Command Line
Interface, CLI). Graphical shells are easier and extremely intuitive (most
people use the mouse in a GUI and never needed to be told how to do it), but
they are very limited. Basically all you can do is click on buttons that were
previously programmed to to some task and input text.

Texts shells (terminals), however, are extremely powerful. You can do virtually
anything with your computer using them. That comes to the cost of terminals not
being intuitive at all. Since KPP is a complicated code for which there is no
graphical interface, we need to use a terminal to compile (``install'') and run
it, simply because this task requires a more powerful tool then your mouse.

Bash (acronym for Bourne Again Shell) is a kind of Unix Shell used by most of
the Linux systems and some Mac OSs. Some other shells can be used to perform
the same tasks (the KPP manual itself also gives some commands in C Shell,
which is another Unix Shell), but we focus on Bash here because it is the most
common and most easily accessible.  Most of Linux distributions use it, and
some Mac OSs use it as well. Furthermore, it can be nativelly installed into
Windows 10, as we will explain in the next section.


\section{Accessing Bash}
\label{bash:accessing-bash}
To access and use Bash, you either need a Bash emulator or to be in an
operational system that supports it natively. Various emulators exist (Cygwin,
cmder, MinGW, etc.) but they are not recommended because some of them contain
many bugs. If you would like to try those anyway, chances are that it'll work,
since we're going to be doing simple tasks and many people use those. However,
running it natively is a always a garantee of no bugs, so (in the spirit of
keeping it general) that's why it's the most recommended option for this guide.

We will briefly go through your options for each of the 3 most common
operational systems.


\subsection{From Windows}
\label{bash:from-windows}
Windows doesn't support Unix Shells natively by default, so here are the
options.

If you're using Windows 10, you can natively install the Ubuntu 14.04 inside
your Windows machine with the Windows 10 anniversary update, which is available
for every up-to-date Windows 10 computer. Directions to do this are very somple
and are given in many places (such as \href{http://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/}{here})
so for now we will not explain them in detail. This will give you Bash running
natively on Windows. But only works for up-to-date Windows 10 computers.

If you do not have Windows 10, you can either install one of the many Bash
emulators for Windows or you can install a Linux virtual machine inside your
Windows computer.  You can do that using \href{https://www.virtualbox.org/wiki/Downloads}{Virtual Box} and installing a Ubuntu-based
distribution (we recommend installing either a recent version of Ubuntu or
Linux Mint 18 (or greater), since these two are most suited for beginners in
Linux). Again, directions on how to do this are straightfoward and exist all
over the internet, so we will not spend time on steps on how to do that.


\subsection{From Mac OS}
\label{bash:from-mac-os}
If you have a Mac, you might already have Bash natively installed, since all
Macs are based on Unix. To find out what your shell is, you need to open a
terminal application (generally under utilities). Then type the command \sphinxtitleref{echo
\$SHELL} and press enter. If the output of the shell is something ending in
Bash, like \sphinxtitleref{/bin/bash}, then you're already running Bash. If it ends in
something else, like \sphinxtitleref{/bin/ksh}, then you're running a different Unix Shell.
Most commands should be the same, but if you want to use this shell you might
have to translate some (which should be easy with the help of Google).

If you're running another terminal and would like to try Bash, you can either
get an Bash emulator for Mac, install a Linux virtual machine (as described in
the Windows section) or change your terminal to Bash. The most recomended here
is to change your Shell to Bash. Instructions on how to do this are easy and
can again be found in many places, including \href{http://osxdaily.com/2012/03/21/change-shell-mac-os-x/}{here}.


\subsection{From Linux}
\label{bash:from-linux}
If you're running Linux you can open a terminal and run the command \sphinxtitleref{echo
\$SHELL} to find out if you're running Bash or not. If you're not you can try to
keep going with your Shell (some commands may need to be translated) or you can
change your default Shell with the \sphinxtitleref{chsh} command. You can find more detailed
information on that in many places, such as \href{http://stackoverflow.com/questions/13046192/changing-default-shell-in-linux}{here}.


\chapter{Compiling KPP}
\label{compiling::doc}\label{compiling:compiling-kpp}
In this chapter we detail how to successfully download and compile KPP
on your system under the Bash environment.


\section{Downloading into your folder}
\label{compiling:downloading-into-your-folder}
One of the first things to be said is: most of the commands we will use will
only work if you're in the right directory (which we will always tell what it
is). So when you open a terminal, that terminal is ``running'' in some directory
in your computer.  You can find out which directory that is by entering the
command \sphinxcode{pwd} which stands for ``Print Working Directory''. That will show you
exactly where you are on your computer.

\begin{notice}{note}{Note:}
You can also use the \sphinxcode{ls} command, which will ``list'' everything you have on
that directory to get a better sense of where you are. Also, you can use the
command \sphinxcode{tree -d {}`pwd{}`}, which shows you your current directory on top, and
the subdirectories in it in a tree-like structure. Try it! This can also be used
to make you get a sense of where you are and what directories are ``around you''.
\end{notice}

To change directories, you can
use the command \sphinxcode{cd}, which stands for ``Change Directory''. So if you want to
go to your downloads directory, you can type \sphinxcode{cd Downloads}, or \sphinxcode{cd
/home/myuser/Downloads} depending on where you are on your terminal (the first
is a relative path (to your current location) and the second is an absolute or
full path; you can read more about relative and absolute paths \href{https://jeremywsherman.com/blog/2011/09/26/absolute-and-relative-paths/}{here}).

\begin{notice}{note}{Note:}
Throughout this document, we'll generally use \sphinxcode{myuser} to refer to
your username in the system. This generally comes right after \sphinxcode{/home/}
and you should change according to your case. So if your user name is \sphinxcode{john}
you'd replace \sphinxcode{/home/myuser} with \sphinxcode{/home/john} in every occasion.
\end{notice}

If you prefer to download KPP through its website manually and unpack it
somewhere, you'll have to go there with your terminal. So, if I unpack it in my
home directory, as soon as I open my terminal I'll have to use \sphinxcode{cd
/home/myuser/kpp-2.2.3}. This command will only work if the path is correct (it
might not work on Windows, for example, which does not have a \sphinxcode{/home} location.
If you're using Bash on Windows it's better to go with the following
alternative.

However, if you're insecure with navigating your directories using your
terminal, it's best to do everything via this second, more straightfoward,
option. It uses solely commands but it's easier. First, as soon as you open the
terminal run the following commands

\begin{Verbatim}[commandchars=\\\{\}]
wget http://people.cs.vt.edu/\PYGZti{}asandu/Software/Kpp/Download/kpp\PYGZhy{}2.2.3\PYGZus{}Nov.2012.zip
unzip kpp\PYGZhy{}2.2.3\PYGZus{}Nov.2012.zip
\PYG{n+nb}{cd} kpp\PYGZhy{}2.2.3
\end{Verbatim}

Line one will automatically download the software to your current directory and
line two will unpack it.  This will create a new directory with all the
contants of the \sphinxcode{.zip} file, so the last command line will move to the
recently-created directory.

Make sure you're in the correct directory by entering \sphinxcode{pwd}, which should show
you that you're on the \sphinxtitleref{kpp-2.2.3} directory. You can also type \sphinxtitleref{ls}, which should
show you a list of everything that was in the zip file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cflags}        \PYG{n}{drv}       \PYG{n+nb}{int}                 \PYG{n}{Makefile}\PYG{o}{.}\PYG{n}{defs}  \PYG{n}{site}\PYG{o}{\PYGZhy{}}\PYG{n}{lisp}
\PYG{n}{cflags}\PYG{o}{.}\PYG{n}{guess}  \PYG{n}{examples}  \PYG{n+nb}{int}\PYG{o}{.}\PYG{n}{modified\PYGZus{}WCOPY}  \PYG{n}{models}         \PYG{n}{src}
\PYG{n}{doc}           \PYG{n}{gpl}       \PYG{n}{Makefile}            \PYG{n}{readme}         \PYG{n}{util}
\end{Verbatim}


\section{Making sure dependecies are installed}
\label{compiling:making-sure-dependecies-are-installed}
Now we are going to set-up the environment to compile KPP. The first step is to
make sure that you have the necessary software. These are called the
dependencies of a program: it is everything the program needs to be available
in the system (softwares, libraries, etc.) before it's installed.

Be sure that FLEX (which is a public domain \href{https://en.wikipedia.org/wiki/Lexical\_analysis}{lexical analizer}) is installed on your
machine. You can run \sphinxcode{flex -{-}version} and if it is installed you should see
something like \sphinxcode{flex 2.6.0}. If instead you see something like \sphinxcode{flex:
command not found} then it means that it is not installed and you're going to
have to install it by running \sphinxcode{sudo apt update \&\& sudo apt install flex} if
you're running Linux natively (depending on your Linux distribution) or by
manually installing downloading and installing the file if you're emulating
(with Cygwin, for example). A quick google search should tell you how to
install it easily. Note: if \sphinxcode{flex} isn't available for you, you might need to
install the Flex-dev package with \sphinxcode{sudo apt install flex-devel.x86\_64}.

Be also sure that \sphinxcode{yacc} and \sphinxcode{sed} are installed by typing \sphinxcode{which yacc}
and \sphinxcode{which sed}. If you see something like \sphinxcode{/usr/bin/sed} or
\sphinxcode{/usr/lib/yacc} then they are installed. If you see an error message, then
you're also going to have to install it manually. Again, a quick google search
should tell you how to do it, although it is very rare that these packages
aren't installed.

\begin{notice}{note}{Note:}
\sphinxcode{flex} and \sphinxcode{yacc} have to do with \href{https://en.wikipedia.org/wiki/Lexical\_analysis}{lexical analysis}
and it's not specially important to know exactly what they do. Suffices to
say that they are used internally by the compiler to generate the executable
file, but you will never have to use them directly when compiling/using KPP.
\sphinxcode{sed}, however, is a very useful \href{https://en.wikipedia.org/wiki/Sed}{text manipulation tool},
but you also won't need to use it
while running KPP.
\end{notice}


\section{Telling your system where KPP is}
\label{compiling:telling-your-system-where-kpp-is}
Now that we have the dependecies installed, we need to make sure that your
computer knows where KPP is in your system. We do that by altering a file
called \sphinxcode{.bashrc}. This file is a simple text file (so can you easily open and
read it, as you'll see) with some very simple commands. Every time you start a
terminal that file is ``read'' internally by the terminal and executed. So inside
that file you can put any command that you could type in the terminal. Thus,
generally, if you want to change something in your terminal so that the change
takes place every time you start it (so you don't have to re-change it over and
over again every time you open it), that's the place to do it. For our purposes
we simply need to add a couple of lines. We'll do that step by step.

\begin{notice}{note}{Note:}
If you're using a terminal other than Bash the \sphinxcode{.bashrc} file will probably
have a slightly different name (like \sphinxcode{.cshrc} e.g.) and the commands might
also differ a bit, but the process and the ideas are the same! You'll just have
to probably do some quick googling.
\end{notice}

First, in the directory where you unpacked KPP, run the command \sphinxcode{pwd} to
print the present working directory and copy its output. You'll need this for
the next steps.

Now you need to open and edit \sphinxcode{.bashrc} which can be done with many programs,
it really depends on what is installed for your (or what you would like to
install).  The best options would be an editor that runs with a GUI. For
Windows users the best option is probably \sphinxcode{notepad++}, while for Linux users
\sphinxcode{gedit} is generally the default GUI option. You can try these (and any other
GUI plain text editors you know) with the commands \sphinxcode{gedit \textasciitilde{}/.bashrc}, or
\sphinxcode{notepad++ \textasciitilde{}/.bashrc} and so forth with the others.

If any of those work, great!, you can edit the file in an intuitive GUI editor.
If not, you're either going to have to install a GUI text editor, or use Nano
by running the command \sphinxcode{nano \textasciitilde{}/.bashrc}. Nano is a very handy text editor
which runs on the terminal itself, however, it's not as eye-pleasing and not as
intuitive as the GUI-based ones.
\begin{figure}[htbp]
\centering
\capstart

\noindent\scalebox{0.900000}{\sphinxincludegraphics{{nano_example}.png}}
\caption{.bashrc example.}\label{compiling:nano-ex}\label{compiling:id1}\end{figure}

If you're forced to use Nano, you should probably read this very quick
\href{http://www.howtogeek.com/howto/42980/the-beginners-guide-to-nano-the-linux-command-line-text-editor/}{tutorial}
to learn how to open, save and close files. It's not as intuitive, but it's
very easy.

Once you open \sphinxcode{.bashrc}, you're going to see something like Fig.
{\hyperref[compiling:nano\string-ex]{\sphinxcrossref{\DUrole{std,std-ref}{.bashrc example.}}}} (in this case open with Nano). Don't worry about the lines of
code. They're probably going to be different for you and that's OK; it really
varies a lot from system to system. You can ignore all those codes and jump to
the last line of the file. After the last line you'll include the following

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{export} \PYG{n+nv}{KPP\PYGZus{}HOME}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}HOME}/kpp\PYGZhy{}2.2.3
\PYG{n+nb}{export} \PYG{n+nv}{PATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PATH}:\PYG{n+nv}{\PYGZdl{}KPP\PYGZus{}HOME}/bin
\end{Verbatim}

except that you should replace \sphinxcode{\$HOME/kpp} with the output of your \sphinxcode{pwd} command.
For example, if the output of \sphinxcode{pwd} was \sphinxcode{/home/myuser/Downloads/kpp-2.2.3} you
should write

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{export} \PYG{n+nv}{KPP\PYGZus{}HOME}\PYG{o}{=}/home/user/Downloads/kpp\PYGZhy{}2.2.3
\PYG{n+nb}{export} \PYG{n+nv}{PATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PATH}:\PYG{n+nv}{\PYGZdl{}KPP\PYGZus{}HOME}/bin
\end{Verbatim}

After this is done, you are going to save and exit. If you're using any option
with a GUI this should be straightforward. With Nano you can save and exit by
pressing control X, choosing the ``yes'' option (by hitting the ``y'' key) when it
asks you to save, and then pressing enter when asked to confirm to name of the
file to save to.

Now your terminal will know where KPP is the next times you start it. But for
the changes to make effect you need to close this terminal and open another
one. So just close the terminal you were working with, open a new one. Now, if
everything worked properly, you should be able to type \sphinxcode{cd \$KPP\_HOME} and go
automatically to your KPP directory. If this worked, we are ready for the next
step, which is telling your system how to compile KPP.


\section{Specifying how to compile}
\label{compiling:specifying-how-to-compile}
Now we actually compile (which is a way of installing) KPP. First, type
\sphinxcode{locate libfl.a} and save the output. If there is no output, use \sphinxcode{locate
libfl.sh} and save the output of that. These commands tell you where the Flex
library is, which we assured was installed somewhere in the system during the
last section. In my case the output was \sphinxcode{/usr/lib/x86\_64-linux-gnu/libfl.a}.

Now in your KPP directory, use the same text editor as before to open a file
called \sphinxcode{Makefile.defs}, which sets how Bash is going to make the executable
code for KPP (i.e., it only gives instructions to your computer on how to
compile it). So type \sphinxcode{gedit Makefile.defs}, or \sphinxcode{nano Makefile.defs} and so
on, depending on the editor you're using.

Once again, you'll see a lot of lines with comments, and the only lines that
matter are those that don't start with \sphinxcode{\#}. There should be 5 lines like this
in this file. The first one starts with \sphinxcode{CC}, which sets the C Compiler. In
this guide we will use the Gnu Compiler Collection, \sphinxcode{gcc}. So make sure that
the line which starts with \sphinxcode{CC} reads \sphinxcode{CC=gcc}.

Next, since we made sure that Flex was installed, make sure the next important
line reads \sphinxcode{FLEX=flex}. On the third step, set the next variable
(\sphinxcode{FLEX\_LIB\_DIR}) with the output we just saved without the last part. So in
my case the output saved was \sphinxcode{/usr/lib/x86\_64-linux-gnu/libfl.a}, so the line
will read \sphinxcode{FLEX\_LIB\_DIR=/usr/lib/x86\_64-linux-gnu}. You should, of course,
replace your line accordingly.

The next two items define some possible extra options for the compilation and
extra directories also to include in the compilation. We will don't have to
worry about those, unless maybe if we need to debug the program for some
reason. Now you can save and close/exit the file.

If we did everything correctly we can compile KPP simply by running the
\sphinxcode{make} command. Many warnings are going to appear on the screen (that's
normal), but as long as no error appears, the compilation will be successful.
You can be sure it was successsful by once again running \sphinxcode{ls} and seeing that
there is now one extra entry on the KPP directory called \sphinxcode{bin}:

\begin{Verbatim}[commandchars=\\\{\}]
bin           doc       gpl                 Makefile       readme     util
cflags        drv       int                 Makefile.defs  site\PYGZhy{}lisp
cflags.guess  examples  int.modified\PYGZus{}WCOPY  models         src
\end{Verbatim}

Now let's test it by running \sphinxcode{kpp test}. If the output is something like

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{KPP}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.2}\PYG{o}{.}\PYG{l+m+mf}{3.}

\PYG{n}{KPP} \PYG{o+ow}{is} \PYG{n}{parsing} \PYG{n}{the} \PYG{n}{equation} \PYG{n}{file}\PYG{o}{.}
\PYG{n}{Fatal} \PYG{n}{error} \PYG{p}{:} \PYG{n}{test}\PYG{p}{:} \PYG{n}{File} \PYG{o+ow}{not} \PYG{n}{found}
\PYG{n}{Program} \PYG{n}{aborted}
\end{Verbatim}

then we know it worked. This tells you the version of KPP and that it couldn't
find any file to work with, which is fine because we didn't give it any yet. If
this works, you can skip to the next section.

If, however you get an output similar to \sphinxcode{kpp: command not found...} then
chances are that \sphinxcode{bin} is a binary executable file, while it should be a
directory containing the binary file. This should not happen, according to the
manual, but for some reason it (very) often does. We need simply to rename that
executable file and put it a directory called \sphinxcode{bin}. This can be done with
the followinf command:

\begin{Verbatim}[commandchars=\\\{\}]
mv bin kpp \PYG{o}{\PYGZam{}\PYGZam{}} mkdir bin \PYG{o}{\PYGZam{}\PYGZam{}} mv kpp bin
\end{Verbatim}

Try this command and then try \sphinxcode{kpp test} again. You should get the correct
output this time, meaning that the system could find KPP successfully.
g


\chapter{Running KPP}
\label{running::doc}\label{running:running-kpp}
Now that KPP is propoerly compiled, we proceed to running the first test case
to make sure it works!


\section{The first test case}
\label{running:the-first-test-case}
We now follow the manual and begin running the Chapman stratospheric mechanism
as a test case. This will allow us to illustrate some key features when running
KPP.

In order to run a simulation on KPP, it needs three things:
\begin{itemize}
\item {} 
a \sphinxcode{.kpp} file (from the KPP directory, type \sphinxcode{ls examples} to see some examples of those)

\item {} 
a \sphinxcode{.spc} file (type \sphinxcode{ls models} to see some examples of those)

\item {} 
a \sphinxcode{.eqn} file (type \sphinxcode{ls models} to see some examples of those)

\end{itemize}

We begin by creating a directory to run this first test. Let's call this
directory \sphinxcode{test1} and create it with \sphinxcode{mkdir test1}. We go to that directory
with \sphinxcode{cd test1}. Let's follow the manual and create a file called \sphinxcode{small\_strato.kpp}
with the following contents:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}MODEL      small\PYGZus{}strato}
\PYG{c+cp}{\PYGZsh{}LANGUAGE   Fortran90}
\PYG{c+cp}{\PYGZsh{}DOUBLE     ON}
\PYG{c+cp}{\PYGZsh{}INTEGRATOR rosenbrock}
\PYG{c+cp}{\PYGZsh{}DRIVER     general}
\PYG{c+cp}{\PYGZsh{}JACOBIAN   SPARSE\PYGZus{}LU\PYGZus{}ROW}
\PYG{c+cp}{\PYGZsh{}HESSIAN    ON}
\PYG{c+cp}{\PYGZsh{}STOICMAT   ON}
\end{Verbatim}

You can do this by typing \sphinxcode{nano small\_strato.kpp} in the \sphinxcode{test1} directory, if
using Nano, or by using another editor of your choice. Then just paste the
content above in the file, save it and exit it.

This file tells KPP what model to use and how to process it. You can learn more
about this in the KPP manual, but basically our file is telling KPP to use the
\sphinxcode{small\_strato} model, output the code in Fortran 90 with double precision
using the Rosenbrock integrator.

If our changes to \sphinxcode{.bashrc} are correct, then KPP should be able to find the
correct model, since the \sphinxcode{small\_strato} model is located in the \sphinxcode{models}
directory, in the KPP home directory. We test this by running KPP on our
recently created file with \sphinxcode{kpp small\_strato.kpp}.

You should see many lines appear onscreen, the last one of them saying \sphinxcode{KPP has succesfully created the model
"small\_strato"}, which means you were sucessfull. Now if you type \sphinxcode{ls},
you'll see many new files:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Makefile\PYGZus{}small\PYGZus{}strato}           \PYG{n}{small\PYGZus{}strato}\PYG{o}{.}\PYG{n}{map}
\PYG{n}{small\PYGZus{}strato\PYGZus{}Function}\PYG{o}{.}\PYG{n}{f90}       \PYG{n}{small\PYGZus{}strato\PYGZus{}mex\PYGZus{}Fun}\PYG{o}{.}\PYG{n}{f90}
\PYG{n}{small\PYGZus{}strato\PYGZus{}Global}\PYG{o}{.}\PYG{n}{f90}         \PYG{n}{small\PYGZus{}strato\PYGZus{}mex\PYGZus{}Hessian}\PYG{o}{.}\PYG{n}{f90}
\PYG{n}{small\PYGZus{}strato\PYGZus{}Hessian}\PYG{o}{.}\PYG{n}{f90}        \PYG{n}{small\PYGZus{}strato\PYGZus{}mex\PYGZus{}Jac\PYGZus{}SP}\PYG{o}{.}\PYG{n}{f90}
\PYG{n}{small\PYGZus{}strato\PYGZus{}HessianSP}\PYG{o}{.}\PYG{n}{f90}      \PYG{n}{small\PYGZus{}strato\PYGZus{}Model}\PYG{o}{.}\PYG{n}{f90}
\PYG{n}{small\PYGZus{}strato\PYGZus{}Initialize}\PYG{o}{.}\PYG{n}{f90}     \PYG{n}{small\PYGZus{}strato\PYGZus{}Monitor}\PYG{o}{.}\PYG{n}{f90}
\PYG{n}{small\PYGZus{}strato\PYGZus{}Integrator}\PYG{o}{.}\PYG{n}{f90}     \PYG{n}{small\PYGZus{}strato\PYGZus{}Parameters}\PYG{o}{.}\PYG{n}{f90}
\PYG{n}{small\PYGZus{}strato\PYGZus{}Jacobian}\PYG{o}{.}\PYG{n}{f90}       \PYG{n}{small\PYGZus{}strato\PYGZus{}Precision}\PYG{o}{.}\PYG{n}{f90}
\PYG{n}{small\PYGZus{}strato\PYGZus{}JacobianSP}\PYG{o}{.}\PYG{n}{f90}     \PYG{n}{small\PYGZus{}strato\PYGZus{}Rates}\PYG{o}{.}\PYG{n}{f90}
\PYG{n}{small\PYGZus{}strato}\PYG{o}{.}\PYG{n}{kpp}                \PYG{n}{small\PYGZus{}strato\PYGZus{}Stoichiom}\PYG{o}{.}\PYG{n}{f90}
\PYG{n}{small\PYGZus{}strato\PYGZus{}LinearAlgebra}\PYG{o}{.}\PYG{n}{f90}  \PYG{n}{small\PYGZus{}strato\PYGZus{}StoichiomSP}\PYG{o}{.}\PYG{n}{f90}
\PYG{n}{small\PYGZus{}strato\PYGZus{}Main}\PYG{o}{.}\PYG{n}{f90}           \PYG{n}{small\PYGZus{}strato\PYGZus{}Util}\PYG{o}{.}\PYG{n}{f90}
\end{Verbatim}

Most of them end with a \sphinxcode{.f90} extension, which tells us they are Fortran
codes. These codes have to compiled into an executable file which is what will
actually process and run the kinetic model. So the next step is to compile
every one of those code together into one executable and run it.

Let's focus for now on the \sphinxcode{Makefile\_small\_strato}. This tells your computer
which Fortran compiler to use to compile, some options and etc. Open the
\sphinxcode{Makefile\_small\_strato} file and find where it says

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}COMPILER = G95}
\PYG{c+c1}{\PYGZsh{}COMPILER = LAHEY}
\PYG{n+nv}{COMPILER} \PYG{o}{=} INTEL
\PYG{c+c1}{\PYGZsh{}COMPILER = PGF}
\PYG{c+c1}{\PYGZsh{}COMPILER = HPUX}
\PYG{c+c1}{\PYGZsh{}COMPILER = GFORTRAN}
\end{Verbatim}

Each of the lines is a different Fortran compiler, and your computer is only
going to see the line that doens't start with a \sphinxcode{\#}. So, currently, these
lines are telling the computer to use the intel Fortran compiler, \sphinxcode{ifort}.

If you are using \sphinxcode{ifort}, you should leave it as it is. Since \sphinxcode{ifort} is
paid, chances are you are using another compiler. If this is the case, put the
\sphinxcode{\#} in front of the \sphinxcode{INTEL} options and take it out of the line which has
the name of your compiler. If you don't know which compiler you have, chances
are you have gfortran, which is free and what we will use here. You can also
install gfortran with \sphinxcode{sudo apt install gfortran}.

So, assuming you're using gfortran, make the lines read

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}COMPILER = G95}
\PYG{c+c1}{\PYGZsh{}COMPILER = LAHEY}
\PYG{c+c1}{\PYGZsh{}COMPILER = INTEL}
\PYG{c+c1}{\PYGZsh{}COMPILER = PGF}
\PYG{c+c1}{\PYGZsh{}COMPILER = HPUX}
\PYG{n+nv}{COMPILER} \PYG{o}{=} GFORTRAN
\end{Verbatim}

Save and exit the file.

Now all you have to do is run \sphinxcode{make -fMakefile\_small\_strato}, which will
compile your fortran code into an executable using the options we just set.
You should see a lot on lines appearing on screen starting with \sphinxcode{gfortran}
and if no error messages appear the compilation was successful.

Now you'll see many more new files, including one called \sphinxcode{small\_strato.exe},
which is your executable file (run \sphinxcode{ls} again to see that). This is the
executable that will actually calculate the concentrations using the model.

To test if it works, run \sphinxcode{./small\_strato.exe}, which will run the executable.
You should see some output on the screen with concentrations, like Fig. {\hyperref[running:test1\string-output]{\sphinxcrossref{\DUrole{std,std-ref}{Output concentrations of the first test case.}}}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\scalebox{0.900000}{\sphinxincludegraphics{{test1_output}.png}}
\caption{Output concentrations of the first test case.}\label{running:test1-output}\label{running:id1}\end{figure}

If this is the case, then your run was successfull and everything worked well!
You just calculated the concetrations of the compounds in the \sphinxcode{small\_strato}
model with the pre-defined initial conditions.


\section{Understanding and improving on the test case}
\label{running:understanding-and-improving-on-the-test-case}
Now let's understand why our run of \sphinxcode{small\_strato.exe} was successful and what
happened. First, by running the \sphinxcode{.exe} file we ran a program that got some initial
concentrations of the substances defined for \sphinxcode{small\_strato} and


\chapter{Understanding the output}
\label{output::doc}\label{output:understanding-the-output}

\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
